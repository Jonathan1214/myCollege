# 第十五章 面向对象程序设计

+ [15.1 OOP：概述](#15.1-OOP：概述)
+ [15.2 定义基类和派生类](#15.2-定义基类和派生类)
+ [15.3 虚函数](#15.3-虚函数)
+ [15.4 抽象基类](#15.4-抽象基类)
+ [15.5 访问控制与继承](#15.5-访问控制与继承)
+ [15.6 继承中类作用域](#15.6-继承中类作用域)
+ [15.7 构造函数与拷贝控制](#15.7-构造函数与拷贝控制)
+ [15.8 容器与继承](#15.8-容器与继承)
+ [15.9 文本查询程序再提](#15.9-文本查询程序再提)

## 15.1 OOP：概述

**面向对象程序设计** 的核心思想是数据抽象、继承和动态绑定。

+ 数据抽象：将类的接口与实现分离
+ 继承：定义相似的类型并对其相似关系建模
+ 动态绑定：在一定程度上忽略相似类型的区别，而以统一的方式使用它们的对象

### 继承

基类和派生类。

对于某些函数，基类希望它的派生类各自定义适合的版本，此时基类将这些函数声明成 **虚函数**，使用关键字 virtual。

派生类必须通过使用 **类派生列表** 明确指出它是从哪个基类继承而来。形式为：冒号，后面紧跟以逗号分隔的基类列表，其中每个基类有名明确的访问说明符。

派生类在其内部对所有重新定义的虚函数进行声明，增加 override 关键字。

### 动态绑定

使用基类的引用或指针调用一个虚函数时将发生动态绑定。

## 15.2 定义基类和派生类

### 15.2.1 定义基类

#### 成员函数与继承

派生类可以继承基类的成员。

定义为 virtual 的成员需要在派生类中重写。

基类通过在其成员函数的声明语句前加上关键字 virtual 使得该函数执行动态绑定。任何除构造函数之外的非静态函数都可以是 virtual 的。

#### 访问控制与继承

派生类可以访问基类 public 和 protected 成员，而无法访问 private 成员，外部函数只能访问 public 成员。

### 15.2.2 定义派生类

派生类必须使用 类派生列表 明确指出它是从哪个基类继承而来。。形式为：冒号，后面紧跟以逗号分隔的基类列表，其中每个基类有名明确的访问说明符：public、private 或 protected。

派生类必须将其继承而来的成员函数中需要覆盖的那些重新声明。

如果一个派生是公有的，则类的公有成员也是派生类接口的组成部分。

#### 派生类中的虚函数

派生类经常（但不总是）覆盖它继承的虚函数。如果没有覆盖，则直接继承虚函数在基类中的行为。

在声明末加 override 关键字表示这是一个继承而来的虚函数。

#### 派生类对象及派生类向基类的类型转换。

派生类对象的组成成分有多个：一个含有派生类自己定义的（非静态）成员的子对象，以及一个与该派生类继承的基类对应的子对象。

因为在派生类对象中含有与基类对应的组成部分，所有我们能把派生类对象当成基类对象来使用，也能将基类的指针或引用绑定到派生类对象中的基类部分上。

这称为 派生类到基类的 类型转换。

派生类对象中含有与其基类对应的组成部分，这一事实是继承的关键所在。

#### 派生类的构造函数

派生类的构造函数必须使用基类的构造函数类构造派生类中的基类部分。

先初始化基类部分，然后按照声明的顺序依次初始化派生类成员。

#### 派生类使用基类成员

派生类可以访问基类的公有成员和受保护的成员。

派生类的作用域嵌套在基类作用域之内。

派生类应该遵守基类的接口，尽管可直接初始化基类中的 protected 成员，但还是应该使用 基类构造函数来初始化。

#### 继承与静态成员

如果基类定义了静态成员，则在整个继承体系中只存在该成员的唯一定义。

#### 派生类的声明

声明派生类无需包含派生列表。

#### 被用作基类的类

被用作基类的类必须是已经定义好了的，而非仅仅声明好。显而易见。

#### 防止继承的发生

类名后加关键字 final，表示该类不能被继承。

### 15.2.3 类型转换和基础

理解基类和派生类之间的类型转换是理解 C++ 语言面向对象编程的关键所在。

引用或指针绑定到这样的对象上：

+ 对象的类型和引用或指针的类型一致。
+ 对象的类型含有一个可接受的 const 类型转换规则。
+ 可将基类的指针或引用绑定到派生类上。

智能指针也支持基类到派生类的转换。

#### 静态类型与动态类型

当我们使用存在继承关系的类型时，必须将一个变量或其他表达式的 静态类型 与该表达式表示对象的 动态类型 区分开。

+ 表达式的静态类型是已知的，是变量声明时的类型或表达式生成的类型。
+ 动态类型则是变量或表达式表示的是内存中的对象的类型，直到程序运行时才已知。

#### 不存在从基类向派生类的隐式类型转换

一个基类的对象既可以以独立的形式存在，也可以作为派生类对象的一部分存在。

#### 对象之间不存在类型转换

派生类向基类的自动类型转换只对指针或引用类型有效。

当我们用一个派生类对象为一个基类对象初始化或赋值时，只有该派生类对象中的基类部分会被拷贝、移动或赋值，它的派生类部分会被忽略掉。

## 15.3 虚函数

当我们使用基类的指针或引用调用一个虚函数成员时会执行动态绑定。

我们必须为每个虚函数提供定义，无论其是否使用到。

### 对虚函数的调用可能在运行时才被解析

当且仅当通过指针或引用调用虚函数时，才会在运行时解析该调用，也只有在这种情况下对象的动态类型才可能与静态类型不同。

### 派生类中的虚函数2

一个派生类的函数如果覆盖率某个基础而来的虚函数，则它的形参类型必须与他覆盖的基类函数完全一致。

### final 和 override 说明符

允许派生类中定义和基类的虚函数名字相同但形参列表不同的函数。这时，虚函数并未被覆盖。

override 说明符显示爆出错误。只有虚函数才能被覆盖。

将某个函数指定为 final，则该继承的虚函数不允许再被派生类覆盖。

final 和 override 说明符出现在形参列表（包括 const 或引用修饰符）以及尾置返回类型之后。

### 虚函数与默认实参

如果虚函数使用默认实参，则基类和派生类中定义的默认实参最好一致。

### 回避虚函数的机制

使用作用域运算符指定特定的虚函数版本，而不执行动态绑定。

通常情况下只有在成员函数或友元函数中的代码才需要使用作用域运算符来回避虚函数机制。

## 15.4 抽象基类

定义 Disc_quote 类。

### 纯虚函数

不希望 Disc_quote 类拥有创建的对象。将 net_price 函数定义成 纯虚 函数而令程序实现我们设计意图。

纯虚函数无需定义，在函数体的位置（声明语句的分号前）书写 `=0` 就可以将一个虚函数说明为纯虚函数，此时无需再加 override 说明符。

可以为纯虚函数提供定义，不过函数体必须定义在类的外部。

### 含有纯虚函数的类是抽象基类

含有（或者未经覆盖直接继承）纯虚函数的类是 抽象基类。抽象基类负责定义接口，而后续的其他类可以覆盖该接口。

不能创建抽象基类的对象。

### 派生类构造函数只初始化它的直接基类

每个类各自控制其对象的初始化过程。

**重构**：重构负责重新设计类的体系以便将操作和/或数据从一个类移动到另一个类中。重构十分普遍。

## 15.5 访问控制与继承

每个类分别控制自己的成员初始化过程，与之类似，每个类还分别控制着其成员对于派生类来说是否 可访问。

### 受保护的成员

protected 关键字声明那些希望与派生类分享但不想被其他公共访问使用的成员。

+ 和私有成员类似，受保护的成员对于类的用户来说是不可访问的。
+ 和公有成员类似，受保护的成员对于派生类的成员和友元来说是可访问的。
+ 派生类的成员或友元只能通过派生类对象来访问基类的受保护成员。派生类对于一个基类对象中的受保护成员没有任何访问特权。

### 公有、私有和受保护继承

继承而来的成员访问权限受限因素：

+ 基类中该成员的访问说明符。
+ 派生类的派生列表中的访问说明符。

派生访问说明符对于派生类的成员及友元能否访问其直接基类的成员没什么影响。对于基类成员的访问权限只与基类中的访问说明符有关。

派生访问说明符的目的是控制派生类用户（包括派生类的派生类）对于基类成员的访问权限。

### 派生类向基类转换的可访问性

派生类向基类的转换是否可访问由使用该转换的代码决定，同时派生类的派生访问说明符也会有影响。假设 D 继承自 B：

+ 只有当 D 公有地继承 B 时，用户代码才能使用派生类向基类的转换；如果 D 继承 B 的方式是受保护的或者私有的，则用户代码不能使用该转换。
+ 不论的 D 是以什么方式继承 B，D 的成员函数和友元都能使用派生类向基类的转换；派生类向其基类的类型转换对于派生类的成员和友元来说永远是可访问的。
+ 入股 D 继承 B 的方式是公有或者受保护的，则 D 的派生类的成员和友元可以用 D 向 B 的类型转换；反之，如果 D 继承 B 的方式是私有的，则不能。

**关键概念**：类的设计与受保护成员。

### 友元与继承

友元关系不能传递，友元关系不能继承。基类的友元在访问派生类成员不具有特殊性，派生类的友元也类似。

不能继承友元关系，每个类负责控制各自成员的访问权限。

### 改变个别成员的可访问性

使用 using 声明。

派生类只能为那些它可以访问的名字提供 using 声明。

### 默认的继承保护级别

默认：使用 class 关键字定义的派生类是私有继承的；使用 struct 关键字定义的派生类是公有继承的。

## 15.6 继承中类作用域

每个类定义自己的作用域，在这个作用域内我们定义类的成员。当存在继承关系时，派生类的作用域嵌套在其基类的作用域之内。

### 在编译时进行名字查找

一个对象、引用或指针的静态类型决定了该对象的哪些成员是可见的。

### 名字冲突与继承

派生类也能重用定义在其直接基类或间接基类中的名字，此时定义在内层作用域（即派生类）的名字将隐藏定义在外层作用域的名字。

### 通过作用域运算符也使用被隐藏的成员

### 一如既往，名字查找先于类型检查

### 虚函数与作用域

虚函数在基类和派生类中必须有相同的形参列表。假如不同，则我们就无法通过基类的引用或指针调用派生类的虚函数了。

### 通过基类调用隐藏的虚函数

### 覆盖重载的函数

## 15.7 构造函数与拷贝控制

### 15.7.1 虚析构函数

继承关系对基类拷贝控制最直接的影响就是基类通常应该定义一个虚析构函数，这样我们就能动态分配继承体系中的对象了。

在基类中将析构函数定义成虚函数以确保执行正确的析构函数版本。

如果基类的析构函数不是虚函数，则 delete 一个指向派生类对象的基类指针将产生未定义的行为。

一个基类总是需要析构函数，而且它能将析构函数设定为虚函数。

#### 虚析构函数将阻止合成移动操作

如果一个类定义了析构函数，即使它通过 =default 的形式使用了合成的版本，编译器也不会为这个类合成移动操作。

### 15.7.2 合成拷贝控制与继承

类的合成拷贝控制成员和其他合成的构造函数对类本身的成员进行初始化、赋值或销毁操作。

#### 派生类中删除的拷贝控制与基类的关系

基类或派生类也能将其合成的默认狗杖函数或者任何一个拷贝控制成员定义成被删除的函数。此外，某些定义基类的方式也可能导致有的派生类成员成为被删除的函数。

+ 如果基类中的默认构造函数或拷贝控制成员是被删除或不可访问的，则派生类中对应的成员将是被删除的。
+ 如果基类中有一个不可访问或删除掉的析构函数，则派生类中合成的默认和拷贝构造函数将是被删除的。
+ 编译器不会合成一个删除掉的移动操作。

#### 移动操作与继承

基类缺少移动操作会阻止派生类拥有自己的合成移动操作，当我们确实需要执行移动操作时，应该首先在基类中进行定义。

### 15.7.3 派生类的拷贝控制成员

派生类构造函数在初始化阶段不但要初始化派生类自己的成员，还负责初始化派生类对象的基类部分。

派生类的拷贝和移动构造函数在拷贝和移动自有成员时，也要拷贝和移动基类部分的成员。类似的，派生类赋值运算符也必须要为其基类部分的成员赋值。

#### 定义派生类的拷贝或移动构造成员

为派生类定义拷贝或移动构造函数时，通常使用对应的基类狗行函数初始化对象的基类部分。

#### 派生类赋值运算符

#### 派生类析构函数

#### 在构造函数和析构函数中调用虚函数

但我们构建一个对象时，需要把对象的类和构造函数的类看成同一个。

如果构造函数或析构函数调用了某个虚函数，则我们应该执行与构造函数或析构函数所属类型相对应的虚函数版本。

### 15.7.4 继承的构造函数

一个类只初始化直接基类，也只基础其直接基类的构造函数。类不能继承默认、拷贝和移动构造函数。

派生类继承基构造函数的方式是提供一条著名基类名单 using 声明语句。`using Disc_quote::Disc_quote;`。

#### 继承的构造函数特点

和普通成员的 using 声明不同，一个构造函数的 using 声明不会改变该构造函数的访问级别。

当一个基类构造函数含有默认实参，这些实参并不会被继承。

默认、拷贝和移动构造函数不会被继承。

## 15.8 容器与继承

当我们使用容器存放继承体系中的对象时，通常必须采取间接存储的方式，因为不允许在容器汇总保存不同类型的元素，所以我们不能把具有继承关系的多种类型的对象直接存放在容器当中。

### 在容器中放置智能指针而非对象

当我们希望在容器中存放具有继承关系的对象时，我们实际上存放的是基类的指针（最好使用智能指针）。

### 15.8.1 编写 Basket 类

我们无法直接使用对象进行面向对象编程。我们必须使用指针和引用。

#### 定义 Basket 的成员

#### 隐藏指针

#### 模拟虚拷贝

## 15.9 文本查询程序再提
