# 第十六章 模板与泛型编程

+ [16.1 定义模板](#16.1-定义模板)
+ [16.2 模板实参推断](#16.2-模板实参推断)
+ [16.3 重载与模板](#16.3-重载与模板)
+ [16.4 可变参数模板](#16.4-可变参数模板)
+ [16.5 模板特例化](#16.5-模板特例化)

## 16.1 定义模板

如果对每种希望比较的类型都不得不重复定义完全一样的函数体，很容易出错。

### 16.1.1 函数模板

定义通用的 **函数模板**。

```C++
    template<typename T>
    int compare(const T &v1, const T &v2;){
        if (v1 < v2) return -1;
        if (v1 > v2) return 1;
        return 0;
    }
```

模板定义以关键字 template 开始，后跟一个 模板参数列表，即以逗号分隔的一个或多个 模板参数 的列表，用 `<>` 包围起来。

模板参数表示在类或函数定义中用到的类型或值，当使用模板时，我们隐式或显示地指定 模板实参，将其绑定到模板参数上。

#### 实例化函数模板

#### 模板类型参数

可将类型参数看作类型说明符。且可来指定返回类型或函数的参数类型。

#### 非类型模板参数

#### inline 和 constexpr 的函数模板

#### 编写类型无关的代码

+ 模板中的函数参数是 const 引用
+ 函数体中的条件判断仅使用 < 比较运算

#### 模板编译

#### 大多数编译错误在实例化期间报告

### 16.1.2 类模板

#### 定义类模板

```C++
    template<typename T> class Blob{ }
```

#### 实例化类模板

使用类模板时，须提供额外信息，即 显示模板实参 列表。

```C++
    Blob<int> ia;
    Blob<int> ia2 = {0, 1, 2, 3, 4};
```

#### 在模板作用域中引用模板类型

类模板的名字不是一个类型名。类模板用来实例化类型，而一个实例化的类型总是包含模板参数的。

#### 类模板的成员函数

`template <typename T> ret-type Blob<T>::member-name(para-list)`。

## 16.2 模板实参推断

## 16.3 重载与模板

## 16.4 可变参数模板

## 16.5 模板特例化
