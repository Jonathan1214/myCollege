# 第十三章 拷贝控制

+ [13.1 拷贝、赋值与销毁](#13.1-拷贝、赋值与销毁)
+ [13.2 拷贝控制和资源管理](#13.2-拷贝控制和资源管理)
+ [13.3 交换操作](#13.3-交换操作)
+ [13.4 拷贝控制示例](#13.4-拷贝控制示例)
+ [13.5 动态内存管理类](#13.5-动态内存管理类)
+ [13.6 对象移动](#13.6-对象移动)

定义类时，我们可以显式指定在此类型的对象拷贝、移动和销毁时做什么。

一个类通过定义五种特殊的成员函数来控制这些操作：

+ 拷贝构造函数
+ 拷贝赋值运算符
+ 移动构造函数
+ 移动赋值运算符
+ 析构函数

## 13.1 拷贝、赋值与销毁

### 13.1.1 拷贝构造函数

构造函数的第一个参数是自身类型的引用，且额外参数都有默认值，则此构造函数是拷贝构造函数。拷贝构造函数不应该是 explicit 的。

#### 合成拷贝构造函数

编译器自动定义的。

每个成员的类型决定它如何拷贝：类类型成员使用其拷贝构造函数完成拷贝；内置类型成员直接拷贝；数组也可以按元素进行拷贝。

#### 拷贝初始化

```C++
    string dots(10, ".");   // 直接初始化
    string s(dots);         // 直接初始化
    string s= dots;         // 拷贝初始化
```

拷贝初始化在以下情况发生：

+ 使用 = 进行初始化
+ 将一个对象作为实参传递给一个非引用类型的形参
+ 从一个返回类型为非引用类型的函数返回一个对象
+ 用花括号列表初始化一个数组中的元素或一个聚合类中的成员

#### 参数和返回值

#### 拷贝初始化的限制

#### 编译器可以绕过拷贝构造函数

### 13.1.2 拷贝赋值运算符

与控制其对象如何初始化一样，类也可以控制其对象如何赋值。

#### 重载赋值运算符

重载运算符，本质上是函数，名字为 `operator` + `要定义的运算符`，如赋值运算符就是一个名为 `operator=` 的函数。运算符函数也有参数列表和返回类型。

参数表示运算符的运算对象。某些运算符必须定义为成员函数。

如果运算符是一个成员函数，其左侧运算对象就绑定到隐式的 this 参数，对于一个二元运算符，例如赋值运算符，其右侧运算对象作为显示参数传递。

为了与内置类型保持一致，赋值运算符通常返回一个指向其左侧运算对象的引用。

#### 合成拷贝赋值运算符

### 13.1.3 析构函数

析构函数执行与构造函数相反的工作，释放除 static 类型之外的资源。

析构函数是类的一个成员函数，名字由波浪号接类名组成，没有返回值，不接受参数，不能被重载，一个类只有一个析构函数。

#### 析构函数完成什么工作

在构造函数中，成员初始化是在构造函数体完成之前进行的。

在析构函数中，首先执行函数体，然后销毁成员，成员按初始化顺序的逆序销毁。

**在一个析构函数中，析构部分是隐式的**。成员被销毁时发生什么依赖于成员的类型。销毁类类型的成员调用类的析构函数，内置类型没有析构函数，销毁内置类型成员什么也不做。

**Note**：隐式销毁一个内置指针类型的成员 *不会 delete* 它所指向的对象。

智能指针是类类型，具有析构函数。

#### 什么时候会调用析构函数

对象被销毁时调用：

+ 变量离开其作用域
+ 对象被销毁，其成员也被销毁
+ 销毁容器，元素被销毁
+ 对于动态分配的对象，delete 时
+ 临时对象在创建其完整表达式时

当指向一个对象的引用或指针离开作用域时，析构函数不会执行。

#### 合成析构函数

### 13.1.4 三/五法则

三个基本操作控制类的拷贝：拷贝构造函数，拷贝赋值运算符和析构函数。

新标准下，类还可以定义一个移动构造函数和一个移动赋值运算符。

这些操作不一定需要全部定义，但是要明白它们是一个整体。

#### 需要析构的函数的类也需要拷贝和赋值操作

决定一个类是否需要定义自己版本的拷贝控制成员时，一个基本原则是确定这个类是否需要一个析构函数。

原因很简单，需要自定义析构的类，一般需要处理内置指针，因内置指针是不会在合成析构函数中 delete 的，所有需要自定义的析构函数，则类的成员含有内置指针，合成的拷贝构造函数和赋值运算符也会失效。

#### 需要拷贝操作的类也需要赋值操作，反之亦然

但析构函数不是必须的。

### 13.1.5 使用 =default

### 13.1.6 阻止拷贝

#### 定义删除的函数

新标准下，可将 *拷贝构造函数* 和 *拷贝赋值运算符* 定义为 **删除的函数** 来阻止拷贝。

虽然我们声明了它们，但不能以任何方式使用它们。

```C++
    struct Nocopy {
        Nocopy() = default;
        Nocopy(const Nocopy&) = delete;
        Nocopy &operator=(const Nocopy&) = delete;
        ~Nocopy() = default;
    };
```

可以对任意函数指定为 delete。

#### 析构函数是不能删除的成员

#### 合成的拷贝控制成员可能是删除的

#### private 拷贝控制

阻止拷贝的类应该使用 `=delete`，而不是将拷贝声明为 private。

## 13.2 拷贝控制和资源管理

通常管理类外资源的类必须定义拷贝控制成员。为了定义这些成员，我们需要确定此类型对象的拷贝语义：使类的行为看起来像值或指针。

类的行为像值，以为着它也有自己的状态。当进行拷贝时，副本和原对象独立。

行为像指针则共享状态.

### 13.2.1 行为像值的类

每个对象都应该拥有自己的拷贝。

#### 类值拷贝赋值运算符

赋值运算符结合律析构函数和构造函数的操作：

+ 赋值操作先销毁左侧运算对象的值
+ 赋值操作会从右侧对象拷贝数据

将对象自身赋值给自己也应该是安全的。

编写的赋值运算符应该是异常安全的————即发生异常时，能将左侧运算对象置于一个有意义的状态。

记住两点：

+ 如果一个对象赋予它自身，赋值运算符必须正确工作。
+ 大多数赋值运算符组合了析构函数和拷贝构造函数的工作。

编写赋值运算符的好的方式：先把右侧对象拷贝到临时变量中，然后再销毁左侧变量。

### 13.2.2 定义行为像指针的类

需定义拷贝构造函数和拷贝赋值运算符，拷贝指针成员本身而不是其指向的对象。仍需要析构函数，但只有当所有对象都销毁时，才能释放指针指向的空间。

定义类似指针的行为，最好使用 shared_ptr 来管理类中的资源，因 shared_ptr 提供类很方便的隐式操作。

如果希望直接管理资源，使用 **引用计数**。

#### 引用计数

工作方式：

+ 除了初始化对象外，每个构造函数（拷贝构造函数除外）还要创建一个引用计数，用来记录有多少对象与正在创建的对象共享状态。
+ 拷贝构造函数不分配新的计数器，而是拷贝给定对象的数据成员，包括计数器。拷贝构造函数递增共享的计数器。
+ 析构函数递减计数器。计数器为 0 时，销毁状态。
+ 拷贝赋值运算符递增右侧运算对象的计数器，递减左侧运算对象的计数器。计数器为 0 时，销毁状态。

将计数器保存在动态内存中。

#### 定义一个使用引用计数的类

```C++
    // 类指针版本
class HasPtr
{
public:
    // 构造函数
    HasPtr(const std::string &s = std::string()):
        ps(new std::string(s)), i(0), use(new std::size_t(1)) { }
    // 拷贝构造函数 递增引用计数
    HasPtr(const HasPtr &p):
        ps(p.ps), i(p.i), use(p.use) { ++*use; }
    HasPtr &operator=(const HasPtr&);
    ~HasPtr();

private:
    std::string *ps;
    int i;
    std::size_t *use;   // 记录成员数
}
```

#### 类指针的拷贝成员『篡改』引用计数

在拷贝赋值运算符和析构函数的定义中，需要对引用计数进行判断，进而决定是否释放空间（主要是考虑到动态内存）。

## 13.3 交换操作

管理资源的类通常还定一个 swap 函数。swap 给那些重排元素顺序的算法使用。

如果自定义类 swap，则使用自定义的，否则使用标准库版本。

希望使用指针，减少内存交换。

### 编写自己的 swap

### swap 应该调用 swap 而不是 std::swap

当成员为类类型时，使用类类型自定义的 swap 而不是 std::swap。

```C++
void swap(HasPtr &lhs, HasPtr &rhs)
{
    using std::swap;
    swap(lhs.ps, rhs.ps);   // 优先使用类自定义版本 当没有时再使用 using 声明的库版本
    swap(lhs.i, rhs.i);
}
```

### 在赋值运算符中使用 swap

定义了 swap 的函数，通常使用 swap 来定义其赋值运算符。这些运算符使用了一种名为 **拷贝并交换** 的技术。

```C++
// 参数按值传递 使用了拷贝构造函数
HasPtr &operator=(HasPtr rhs) {
    swap(*this, rhs);   // rhs 指向本对象使用的内存
    return *this;       // rhs 被销毁，从而 delete 类 rhs 中的指针
}
```

该技术自动处理了自赋值情况且天然就是异常安全的。

## 13.4 拷贝控制示例

见目录下的 `Message.hh` 和 `Message.cpp`。

## 13.5 动态内存管理类

## 13.6 对象移动

在新标准中，可以用容器保存不可拷贝的类型，只要它们可以被移动即可。

### 13.6.1 右值引用

新的引用类型————右值引用，即必须绑定到右值的引用。通过 `&&` 获取右值引用。

右值引用只能绑定到一个将要销毁的对象，因此可以自由地将一个右值引用的资源移动到『另一个』对象。

#### 左值持久，右值短暂

左值有持久的状态，而右值要么是字面常量，要么是在表达式求值过程中创建的临时对象

#### 变量是左值

#### 标准库 move 函数

可以显示地将一个左值转换为对应的右值引用类型，还可以调用一个名为 move 的函数来获得绑定到左值上的右值引用。定义在头文件 utility 中。

move 调用告诉编译器：我们有一个左值，但我们希望像使用右值一样使用它。这意味着我们将它视为右值。

### 13.6.2 移动构造函数和移动赋值运算符

### 13.6.3 右值引用和成员函数
