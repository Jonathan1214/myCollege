# 第三章 字符串、向量和数组

[返回总目录](../../README.md)

+ [3.1 命名空间的 using 声明](#3.1-命名空间的-using-声明)
+ [3.2 标准库类型 string](#3.2-标准库类型-string)
+ [3.3 标准库类型 vector](#3.3-标准库类型-vector)
+ [3.4 迭代器介绍](#3.4-迭代器介绍)
+ [3.5 数组](#3.5-数组)
+ [3.6 多维数组](#3.6-多维数组)

## 3.1 命名空间的 using 声明

使用 **using 声明**，更简单的途径使用到命名空间中的成员。

using 声明格式如下：

> using *namespace*::name;

有了这个声明，就可以直接访问命名空间中的名字。

### 每个名字都需要独立的 using 声明

### 头文件不应包含 using 声明

## 3.2 标准库类型 string

标准库类型 **string** 表示可变长度的字符序列，使用时先包含 string 头文件，string 的定义在命名空间 std 中。

### 3.2.1 定义和初始化 string 对象

如何初始化类的对象由类本身决定。一个类可以有很多种初始化方式，在初始值数量或初始值类型上略有不同。

初始化 string 对象的方式
| 语法 | 解释 |
| :---- | :---- |
| string s1 | 默认初始化，s1 为空串 |
| string s2(s1) | s2 是 s1 的副本 |
| string s3("value") | s3 是字面值『value』的副本，去掉空字符 |
| string s3 = "value" | 等价于上一条 |
| string s4(n, 'c') | 把 s4 初始化为由 n 个字符 c 组成的串 |

#### 直接初始化和拷贝初始化

使用等号初始化变量，执行的是 **拷贝初始化**，不使用等号时，执行的是 **直接初始化**。

### 3.2.2 string 对象上的操作

string 的操作
| 语法 | 解释 |
| :---- | :---- |
| os << s | 将 s 写入到 os，并返回 os |
| is >> s | 从 is 中读取字符串给 s，字符串以空白分隔，返回 is|
| getline(is, s) | 从 is 中读取一行赋给s，返回is |
| s.empty() | s为空返回 true，否则返回 false |
| s.size() | 返回 s 中字符的个数 |
| s[n] | 返回 s 中第 n 个字符的引用，n 从 0 开始 |
| s1+s2 | 返回 s1 和 s2 连接后的结果 |
| s1 = s2 | 用 s2 的副本替代原来 s1 的值 |
| s1 == s2 | s1 和 s2 完全一样则相等，对大小写敏感 |
| s1 != s2| 同上 |
| <, <=, >, >= | 利用字符在字典中的顺序比较，对大小写敏感 |

#### 读写 string 对象

执行读取操作时，string 对象会忽略开头的控制符，从第一个真正的字符开始读，直到遇到下一个空白处。

#### 读取未知数量的 string 对象

```C++
int main()
{
    string word;
    while (cin >> word)
        cout << word << endl;
    return 0;
}
```

#### 使用 getline 读取一整行

getline() 函数的参数是一个输入流和一个 string 对象，从给定的输入流中读入内容，直到遇到换行符为止（换行符也被读进来），然后把读取的值保存到 string 对象中（丢弃换行符）。

#### string 中的 empty 和 size 操作

#### string::size_type 类型

size 函数返回的类型不是 int 或 unsigned，而是 **size_type** 类型。

如果一条表达式中已经有了 size() 函数就不要再使用 int 了，这样可以避免混用 int 和 unsigned 可能带来的问题。

#### 比较 string 对象

依照字典顺序：

1. 如果两个 string 对象的长度不同，且较短 string 对象的每个字符都与较长 string 对象对应位置上的字符相同，就说较短 string 对象小于较长 string 对象。
2. 如果两个 string 对象在某些对应的位置上不一致，则 string 对象比较的结果是对象中第一对相异字符比较的结果。

#### 为 string 对象赋值

#### 两个 string 相加

得到一个新的 string 对象，相当于字符串的连接。

#### 字面值和 string 对象相加

即使一种类型并非所需，我们也可以使用它，不过前提是这种类型可以自动转换成所需的类型。

标准库允许把字符字面值和字符串字面值转换成 string 对象，在需要 string 对象的地方可以用这两种字面值代替。

```C++
    string s1 = "world";
    string s2 = "hello" + ", "; // 错误
    string s3 = ", " + s1;      // 正确
    string s4 = "hello " + s1 + ", ";   // 正确
    string s5 = "hello" + ", " + s1;    // 错误
```

**警告**：字符串字面值和 string 对象不是同一类型，这是历史问题。

### 3.2.3 处理 string 对象中的字符

单独处理 string 对象中的单个字符问题。

cctype 头文件中的函数：
| 函数 | 解释 |
| :---- | :---- |
| isalnum(c) | 当 c 是字母或数字时为真 |
| isalpha(c) | 当 c 是字母时为真 |
| iscntrl(c) | 当 c 是控制字符为真 |
| isdigit(c) | 当 c 是数字时为真 |
| isgraph(c) | 当 c 不是空格但可打印时为真 |
| islower(c) | 当 c 是小写字母时为真 |
| isprint(c) | 当 c 是可打印字符为真（包括空格）|
| ispunct(c) | 当 c 是标点符号为真 |
| isspace(c) | 当 c 是空白为真 |
| isupper(c) | 当 c 是大写字母为真 |
| isxdigit(c) | 当 c 是十六进制数字为真 |
| tolower(c) | 输出小写字母 |
| toupper(c) | 输出大写字母 |

#### 处理每个字符？使用基于范围的 for 语句

**范围 for 语句**：遍历给定序列中的每个元素并对序列中的每个值执行某种操作。语法：

> for (*declaration* : *expression*):
> statement

其中，*expression* 部分是一个对象，用于表示一个序列。*declaration* 部分负责定义一个变量，该变量将用于访问序列中的基础元素。每次迭代，*declaration* 部分的变量都会被初始化为 *expression* 部分的下一个元素值。

```C++
    string str('some string');
    for (auto c : str)
        cout << c << endl;
```

#### 使用范围 for 语句改变字符串中的字符

如果想要改变 string 对象中字符的值，必须把循环变量定义成引用类型。记住引用只是给变量一个别名。

```C++
    string s("hello world!!");
    for (auto &c : s)
        c = toupper(c);
    cout << s << endl;
```

#### 只处理一部分字符？

两种方式：使用下标或迭代器。

**下标运算符**（[]）接受参数是 string::size_type 类型的值，这个参数表示要访问字符的位置，返回值是该位置上字符的引用。

**Note**：string 对象的下标必须大于 0 而小于 s.size()。

####　使用下标进行迭代

#### 使用下标执行随机访问

## 3.3 标准库类型 vector

标准库类型 **vector** 表示对象的集合，其中所有对象的类型都相同。也被称作为 **容器**。

要想使用 vector，必须包含适当的头文件。

```C++
    #include <vector>
    using std::vector;
```

C++ 既有 **类模板**，也有 **函数模板**，其中 vector 是一个类模板。

模板本身不是类或函数，相反可以将模板看作为编译器生成类或函数编写的一份说明。编译器根据模板创建的类或函数的过程称为 **实例化**。

对于类模板而言，提供一些额外信息指定模板到底实例化成什么样的类，需要提供的信息由模板决定。

```C++
    vector<int> ivec;
    vector<Sales_item> Sales_vec;
    vector<vector<string>> file;
```

vector 能容纳绝大多数类型的对象作为其元素，但因为引用不是对象，所以不存在包含引用的 vector。

早期版本中：**vector<vector<int\> >**，需要有空格。

### 3.3.1 定义和初始化 vector 对象

和任何一种类类型一样，vector 模板控制着定义和初始化向量的方法。

初始化 vector 对象的方法
| 语法 | 解释 |
| :---- | :---- |
| vector<T\> v1 | v1 是一个空 vector，它潜在的元素是 T 类型，执行默认初始化 |
| vector<T\> v2(v1) | v2 中包含有 v1 所有元素的副本 |
| vector<T\> v2 = v1 | 同上 |
| vector<T\> v3(n, val) | v3 包含了 n 个重复的元素，每个元素的值都是 val |
| vector<T\> v4(n) | v4 包含了 n 个重复地执行了值初始化的对象 |
| vector<T\> v5{a, b, c...} | v5 包含了初始值个数的元素，每个元素被赋予相应的初始值 |
| vector<T\> v5 = {a, b, c...} | 同上 |

#### 列表初始化 vector 对象

例外：

+ 拷贝初始化时（使用 =），只能提供一个初始值。
+ 如果提供的是一个类内初始值，则只能使用拷贝初始化或花括号的形式初始化。
+ 如果提供的是初始值元素的列表，则只能把初始值都放在花括号里进行列表初始化，而不能放在圆括号里。

#### 创建指定数量的元素

#### 值初始化

只提供 vector 对象容纳的元素个数而不用给出其初值。库会创建一个 **值初始化** 的元素初值，并把它赋给容器中所有的元素。这个初始值由 vector 对象中元素的类型决定。

#### 列表初始值还是元素数量？

容器中对象类型支持数值时，使用花括号和圆括号区分：花括号是列表初始值，圆括号是元素数量。

当初始化使用了花括号的形式但是提供的值又不能用来列表初始化，就要考虑用这样的值来构造 vector 对象。

### 3.3.2 向 vector 对象中添加元素

使用 **push_back** 方法向其中添加元素。

#### 向 vector 中添加元素蕴含的编程假定

必须要确保所写的循环正确无误，特别是在循环有可能改变 vector 对象容量时。

如果循环体内部包含有向 vector 对象中添加元素的语句，则不能使用范围 for 循环。

**警告**：范围 for 语句体内不应改变其所遍历序列的大小。

### 3.3.3 其他 vector 操作

vector 支持的操作：
| 语法 | 解释 |
| :---- | :---- |
| v.empty() | 显而易见 |
| v.size() | 返回 v 中元素的个数 |
| v.push_back(t) | 向 v 的尾端添加元素t |
| v[n] | 返回 v 中第 n 个位置元素的引用 |
| v1 = v2 | 拷贝赋值 |
| v1 = {a, b, c...} | 拷贝替换 |
| v1 == v2 | 当且仅当所有元素相同且对应位置相同 |
| v1 != v2 | 同上去非即可 |
| <, <=, >, >= | 顾名思义，以字典顺序进行比较 |

vector 对象的类型总是包含着元素的类型。

#### 计算 vector 内对象的索引

#### 不能用下标形式添加元素

**警告**：vector 对象（及 string 对象）的下标运算符可用于访问已存在的元素，而不能用于添加元素。

## 3.4 迭代器介绍

### 3.4.1 使用迭代器

有迭代器的类型同时拥有返回迭代器的成员。如 **begin** 和 **end** 成员。begin 成员返回指向第一个元素的迭代器，end 成员返回指向『尾元素的下一个位置』的迭代器，也被称为 **尾后迭代器**。

若容器为空，则 end 和 begin 都返回尾迭代器。

#### 迭代器运算符

标准容器迭代器的运算符
| 语法 | 解释 |
| :---- | :---- |
| *iter | 返回迭代器 iter 所指元素的引用 |
| iter->mem | 解引用 iter 并获取该元素的名为 mem 的成员，等价于 (*iter).mem |
| ++iter | 令 iter 指向容器的下一个元素 |
| --iter | 令 iter 指向容器的上一个元素 |
| iter1 == iter2 | 是否相等，指向同一容器的同一元素或同一尾迭代器 |
| iter1 != iter2 | 同上 |

#### 将迭代器从一个元素移动到另外一个元素

#### 迭代器类型

使用 iterator 和 const_iterator 表示迭代器类型。

+ iterator 能读取能修改指向的值
+ const_iterator 能读取但不能修改指向的值

#### begin 和 end 运算符

返回的类型取决于对象是否是常量。而使用 cbegin 和 cend 可以保证返回的是 const_iterator。

#### 结合解引用和成员访问操作

解引用迭代器可获得迭代器所指的对象，如果该对象的类型恰好是类，则可以进一步访问它的成员。

#### 某些对 vector 对象的操作会使迭代器失效

任何一种可能改变 vector 对象容量的操作，如 push_back，都将使 vector 对象的迭代器失效。

**警告**：使用了迭代器的循环体，都不要向迭代器所属容器中添加元素。

### 3.4.2 迭代器运算

string 和 vector 迭代器支持的运算：
| 语法 | 解释 |
| :---- | :---- |
| iter + n | 仍为迭代器，向前移动 n 个元素 |
| iter - n | 向后移动 n 个元素 |
| iter1 += n | 易知 |
| iter1 -= n | 易知 |
| iter1 - iter2 | 迭代器间距离，即中间的元素个数 |
| <, <=, >, >= | 易知 |

#### 迭代器的算术运算

迭代器间的减法说得结果为 **difference_type** 类型的带符号整型数，可正可负。

#### 使用迭代器运算

二分搜索算法。

## 3.5 数组

数组的大小确定不变，不能随意向数组中添加元素。

### 3.5.1 定义和初始化内置数组

数组是一种复合类型。声明为 `a[d]`，d 为数组维度，编译时必须已知，故必须为常量表达式。

定义数组时需指定数组的类型，不允许用 auto 关键字由初始值列表推断类型。数组的元素为对象，故不存在引用的数组。

#### 显示初始化数组元素

列表初始化数组时，可不指明维度，如指明的维度比列表元素个数多，多余的数用默认值进行初始化。

#### 字符数组的特殊性

字符数组可以用字符字面值对数组进行初始化。注意结尾处的空字符。

```C++
    char a1[] = {'C', '+', '+'};
    char a2[] = {'C', '+', '+', '\0'};
    char a3[] = "C++";
    const char a4[6] = "Daniel";        // 错误 长度不为 6
```

a1 维度是3，a2 和 a3 维度是4，a4定义错误。

#### 不允许拷贝和赋值

#### 理解复杂的数组声明

数组的指针，数组的引用，存放指针的数组。

```C++
    int *ptrs[10];              // ptrs 是存放有10个 int 指针的数组
    int &refs[10] = /* ?*/;     // 错误
    int (*Parray)[10] = &arr;   // Parray 指向一个含有 10 个 int 元素的数组
    int (&arrRef)[10] = arr;    // arrRef 引用一个含有 10 个 int 的数组
```

就数组而言，对其声明应该从数组的名字开始，并由内向外读，更容易理解。

### 3.5.2 访问数组元素

数组也能使用范围 for 语句或下标运算符来访问，数组索引从 0 开始。

数组下标被定义为 **size_t** 类型，该类型是一种机器相关的无符号类型，在 cstddef 中定义了该类型。

#### 检查下标的值

### 3.5.3 指针和数组

数组会被编译器转换为指针，在许多用到数组名的地方，会自动替换为指向数组首元素的指针。

```C++
    string nums[] = {"one", "two", "three"};
    string *p = &nums[0];
    string *p2 = nums;
```

当使用数组作为一个 auto 变量的初始值时，推断得到的类型是指针而非数组。

当使用 decltype 时，上述情况不会发生。

#### 指针也是迭代器

vector 和 string 迭代器支持的运算，数组的指针全部支持。

#### 标准库函数 begin 和 end

使用数组作为它们的参数，分别返回指向数组第一个元素的指针和数组尾后指针。这两个函数定义在 iterator 头文件中。

#### 指针运算

所有迭代器运算，执向数组的指针都支持。

两指针相减得到的类型是 ptrdiff_t 的标准库类型。

#### 解引用和指针运算交互

#### 下标和指针

内置的下标运算符所用的索引值不是无符号类型，可以为负数，这一点与 vector 和 string 不同。

### 3.5.4 C 风格字符串

字符串字面值是一种通用结构的实例，这种结构即是由 C++ 从 C 继承而来的 **C 风格字符串**。

#### C 标准库 String 函数

定义在 cstring 头文件中的函数，可操作 C 风格字符串。传入此类函数的的指针必须指向以空字符为结束的数组。

C 风格字符串函数：
| 语法 | 解释 |
| :---- | :---- |
| strlen(p) | 返回 p 的长度，不计空字符 |
| strcmp(p1, p2) | 比较 p1 和 p2 的相等性 |
| strcat(p1, p2) | 把 p2 附加到 p1 后 |
| strcpy(p1, p2) | p2 拷贝给 p1，返回 p1 |

#### 比较字符串

#### 目标字符串的大小由调用者指定

**警告**：推荐使用 string 而非 C 风格字符串。

### 3.5.5 与旧代码的接口

#### 混用 string 对象和 C 风格字符串

任何出现字符串字面值的地方都可以用以空字符结束的字符数组来替代：

+ 允许使用以空字符结束的字符数组来初始化 string 对象或为 string 对象赋值。
+ 在 string 对象的加法运算中允许使用以空字符结束的字符数组作为其中一个运算对象。

如果程序某处需要 C 风格字符串，使用 c_str 成员函数。

#### 使用数组初始化 vector 对象

允许使用数组来初始化 vector 对象：

```C++
    int int_arr[] = {1, 2, 3, 4};
    vector<int\> subVec(begin(int_arr), end(int_arr));
```

**建议**：尽量使用标准库类型而非数组。

## 3.6 多维数组

通常来说的多维数组是数组的数组。对于二维数组而言，第一个维度称作行，第二个称作列。

### 多维数组初始化

```C++
    int ia[3][4] = {
        {0, 1, 2, 3},
        {4, 5, 6, 7},
        {8, 9, 10, 11}
    };
```

### 多维数组的下标和引用

### 使用范围 for 语句处理多维数组

**Note**：要使用范围 for 语句处理多维数组，除了最内层的循环外，其他所有循环的控制变量都应该是引用类型。这是为了防止被自动转成指针。

### 指针和多维数组

### 类型别名简化多维指针
