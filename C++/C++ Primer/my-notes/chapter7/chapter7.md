# 第七章 类

+ [7.1 定义抽象数据类型](#7.1-定义抽象数据类型)
    + [7.1.1 设计 Sales_data 类](#7.1.1-设计-Sales_data-类)
    + [7.1.2 定义改进的 Sales_data 类](#7.1.2-定义改进的-Sales_data-类)
    + [7.1.3 定义类相关的非成员函数](#7.1.3-定义类相关的非成员函数)
    + [7.1.4 构造函数](#7.1.4-构造函数)
    + [7.1.5 拷贝、赋值和析构](#7.1.5-拷贝、赋值和析构)
+ [7.2 访问控制与封装](#7.2-访问控制与封装)
    + [7.2.1 友元](#7.2.1-友元)
+ [7.3 类的其他特性](#7.3-类的其他特性)
    + [7.3.1 类成员再探](#7.3.1-类成员再探)
    + [7.3.2 返回 *this 的成员函数](#7.3.2-返回-*this-的成员函数)
    + [7.3.3 类类型](#7.3.3-类类型)
    + [7.3.4 友元再探](#7.3.4-友元再探)
+ [7.4 类的作用域](#7.4-类的作用域)
    + [7.4.1 名字查找和类的作用域](#7.4.1-名字查找和类的作用域)
+ [7.5 构造函数再探](#7.5-构造函数再探)
    + [7.5.1 构造函数初始值列表](#7.5.1-构造函数初始值列表)
    + [7.5.2 委托构造函数](#7.5.2-委托构造函数)
    + [7.5.3 默认构造函数的作用](#7.5.3-默认构造函数的作用)
    + [7.5.4 隐式类类型转换](#7.5.4-隐式类类型转换)
    + [7.5.5 聚合类](#7.5.5-聚合类)
    + [7.5.6 字面值常量类](#7.5.6-字面值常量类)
+ [7.6 类的静态成员](#7.6-类的静态成员)

类的基本思想是 **数据抽象** 和 **封装**。

数据抽象是一种依赖于 **接口** 和 **实现** 分离的编程技术。类的接口包括用户所能执行的操作，类的实现则包括类的数据成员、负责接口实现的函数体以及定义所需的各种私有函数。

封装实现了类的接口和实现的分离。

类要想实现数据抽象和封装，需要首先定义一个 **抽象数据类型**。

## 7.1 定义抽象数据类型

### 7.1.1 设计 Sales_data 类

Sales_data 的接口包含以下操作：

+ 一个 isbn 成员函数，返回对象的 ISBN 编号。
+ 一个 combine 成员函数，用于将一个 Sales_data 加到另一个对象上。
+ 一个名为 add 的函数，执行两个 Sales_data 对象的加法。
+ 一个 read 函数，将数据从 istream 读入到 Sales_data 对象中。
+ 一个 print 函数，将 Sales_data 对象的值输出到 ostream。

#### 使用改进的 Sales_data 类

### 7.1.2 定义改进的 Sales_data 类

成员函数的声明必须在类的内部，其定义则无此要求。

作为接口组成部分的非成员函数，其定义和声明在类的外部。

**Note**：定义在函数内部的成员函数是隐式的 inline 函数。

```C++
struct Sales_data
{
    std::string isbn() const { return bookNo; }
    Sales_data& combine(const Sales_data&);
    double avg_price() const;
    std::string bookNo;
    unsigned units_sold = 0;
    double revenue = 0.0;
};

Sales_data add(const Sales_data&, const Sales_data&);
std::ostream &print(std::ostream&, const Sales_data&);
std::istream &read(std::istream, Sales_data&);
```

#### 引入 this

对 isbn 成员的调用：`total.isbn()`。使用点运算符来访问 total 对象的 isbn 成员，然后调用它。

当我们调用成员函数时，实际上是在替某个对象调用它。成员函数通过一个名为 **this** 的额外的隐式参数来访问调用它的那个对象。当我们调用一个成员函数时，用请求该函数的对象地址初始化 this。

在成员函数内部，可以直接使用调用该函数的对象的成员，而无需通过成员访问运算符来实现，可以通过 this 来实现，任何对类成员的直接访问都被看作 this 的隐式调用。

对我们而言，this 形参是隐式定义的，且 this 是一个常量指针，不允许改变 this 中保存的地址。

#### 引入 const 成员函数

isbn 的参数列表后面紧跟一个 const 关键字，其作用是修改隐式 this 指针的类型。

默认情况下，this 的类型是指向类类型非常量版本的常量指针，如上例子中 this 类型为 `Sales_data *const`。尽管 this 是隐式的，但它仍遵守默认初始化规则，即默认情况下不能把 this 绑定到一个常量对象上（即我们的类不能是常量）。这使得我们不能在一个常量对象上调用普通成员函数。

故必须把 this 声明为 **指向常量的常量指针**，由于 this 是隐式的，C++ 支持在成员函数的参数列表后加上 const 完成功能。

这样使用 const 的成员函数被称作 **常量成员函数**。

**Note**：常量对象，以及常量对象的引用或指针都只能调用常量成员函数。

#### 类作用域和成员函数

编译器分两步处理类：首先编译成员的声明，然后才轮到成员函数体。

因此，成员函数体可以随意使用类中的其他成员而无需在意这些成员出现的次序。

#### 在类的外部定义成员函数

成员函数的定义必须与它的声明匹配。类外部定义的成员的名字必须包含它所属的类名。

```C++
double Sales_data::avg_price() const {
    if (units_sold)
        return revenue / units_sold;
    else
        return 0;
}
```

#### 定义一个返回 this 对象的函数

combine 类似于 `+=`，调用该函数的对象是运算符左侧的运算对象，右侧运算对象则通过显示的实参被传入函数。

关注返回类型和返回语句。定义的函数类似于某内置运算符时，应该另该函数的行为尽量模仿这个运算符。内置的赋值运算符把它的左侧对象当成左值返回，因此为与它保持一致，**combine 函数必须返回引用类型**。

把调用函数的对象当成一个整体来访问：`return *this`，返回 total 的引用。

好像没有用什么变量去接收这个返回的引用，是可以忽略吗？

```C++
Sales_data& Sales_data::combine(const Sales_data &rhs) {
    units_sold += rhs.units_sold;
    revenue += rhs.revenue;
    return *this;              // 返回调用该函数的对象
}
```

### 7.1.3 定义类相关的非成员函数

辅助函数，这些函数定义的操作从概念上来说属于类的接口组成部分，但它们实际上并不属于类。

如果函数在概念上属于类但是不定义在类中，则它一般应与类声明（而非定义）在同一个文件中。

#### 定义 read 和 print 函数

IO 类属于不能被拷贝的类型，故应该定义成引用。

执行输出任务的函数应该尽量减少对格式的控制，这样可以确保由用户代码来决定是否换行。

#### 定义 add 函数

### 7.1.4 构造函数

每个类都分别定义了它的对象被初始化的方式，通过一个或几个特殊的成员函数来控制，这些函数被叫做 **构造函数**。只要类的对象被创建，就会执行构造函数。

构造函数是一个非常复杂的问题

构造函数名与类名相同，但无返回类型，且有参数列表和函数体（均可为空）。

类可以包含多个构造函数，与重载函数类似，不过构造函数间必须存在参数数量或参数类型上的区别。

构造函数不能被声明成 const，因构造函数是构造 const 对象的。

#### 合成的默认构造函数

没有提供初始值，类通过 **默认构造函数** 控制默认初始化，无需任何实参。

如果类没有显示定义构造函数，编译器会为我们隐式定义，被称为 **合成的默认构造函数**。

+ 如果存在类内初始值，用它初始化。
+ 否则，执行默认初始化。

#### 某些类不能依赖于合成的默认构造函数

合成的默认构造函数只适合非常简单的类。

**Note**：只有当类没有声明任何构造函数时，编译器才会自动地生成默认构造函数。

对于某些类来说，合成的默认构造函数可能执行错误的操作。因定义在块中的内置类型或复合类型的对象被默认初始化，则它们的值是未定义的。

有些时候编译器不能为某些类合成默认的构造函数。如类中含有其他类型的类。

#### 定义 Sales_data 的构造函数

定义四个不同的构造函数。

```C++
    Sales_data() = default;                                     // 1
    Sales_data(const std::string &s) : bookNo(s) {}             // 2
    Sales_data(const std::string &s, unsigned n, double p) :    // 3
               bookNo(s), units_sold(n), revenue(p*n) {}
    Sales_data(std::istream &);                                 // 4
```

#### = default 的含义

在 C++11 标准中，如果需要默认构造函数，使用 `=default` 执行此功能。

#### 构造函数初始值列表

构造函数 2 和 3 均使用了构造函数初始值列表。

出现了冒号和花括号之间的代码，这是新的部分，称之为构造函数初始值列表，负责为创建对象的一个或几个数据成员赋初值。具体形式见上面的声明代码。

通常，构造函数使用类内初始值不失为一种好的选择，因只要这样的初始值存在，我们就能确保成员赋予了一个正确的值，若编译器不支持类内初始值，则要在构造函数中显示初始化。

#### 在类的外部定义构造函数

构造函数声明 4 的定义在类外进行。

```C++
Sales_data::Sales_data(std::istream &is) {
    read(is, *this); // 从 is 中读取交易信息存入 this 对象中
}
```

该构造函数没有函数初始值列表。

### 7.1.5 拷贝、赋值和析构

除定义类的对象如何被初始化之外，类还需要控制拷贝、赋值和销毁对象时发生的行为。如果我们不指定，编译器会自动合成。

#### 某些类不能依赖于合成的版本

## 7.2 访问控制与封装

使用 **访问说明符** 加强类的封装性。

+ 定义在 public 说明符之后的成员在整个程序内可被访问，public 成员定义类的接口。
+ 定义在 private 说明符之后的成员可以被类的成员函数访问，但是不能被使用该类的代码访问，private 部分封装了类的实现细节。

一个类可包含 0 个或多个访问说明符，对其出现次数也无限定，每个说明符有效范围为直到下一个说明符出现或到达类的结尾处。

### 使用 class 或 struct 关键字

同一风格：希望定义类的所有成员是 public 时，使用 struct，反之，希望是 private 时，使用 class。

class 和 struct 的区别仅在于默认的范围权限不同，class 是 private，struct 是 public。

### 7.2.1 友元

类可以运行其他类或函数访问它的非公有成员，可令其他类或函数为其 **友元**。只需在声明最前面添加 **friend** 关键字即可。

友元的声明只能出现在类定义的内部，且最好在函数的开头或结尾集中声明友元。

#### 友元的声明

友元的声明仅仅指定了访问权限，并非通常意义上的函数声明。

需在友元声明外再次声明，直接写在类头文件中，并在头文件中定义（类外部）。

## 7.3 类的其他特性

### 7.3.1 类成员再探

定义两个相互关联的类 Screen 和 Window_mgr。

#### 定义一个类型成员

将类型使用类型别名，隐藏实现细节，且类型别名声明应该为 public。

且用来定义类型的成员必须先定义后使用，故类型成员通常出现在类开始的地方。

#### Screen 类的成员函数

```C++
class Screen
{
public:
    typedef std::string::size_type pos;
    Screen() = default;

    Screen(pos ht, pos wd, char c): height(ht), width(wd),
            contents(ht * wd, c) {}
    char get() const
        { return contents[cursor];}         // 隐式内联
    inline char get(pos ht, pos wd) const;  // 显式内联
    Screen &move(pos r, pos c);

private:
    pos cursor = 0;
    pos height = 0, width = 0;
    std::string contents;
};
```

#### 令成员作为内联函数

定义在类内部的函数是默认被声明为内联函数的。

定义在类外部的，可在类内声明函数时指定为内联，也可在外部定义时，加上 inline 关键字，效果相同。

虽然是合法的，但无需在两个地方同时说明 inline。

最好只在类外部定义的地方说明 inline，使类更容易理解。

#### 重载成员函数

成员函数也可被重载。

#### 可变数据成员

一个 **可变数据成员** 永远不会是 const，即使它是 const 对象的成员，故一 const 成员函数可以改变一个可变成员的值。

#### 类数据成员的初始值

希望 Window_mgr 类开始时总有默认初始化的 Screen。在 C++11 标准中，最好的方式就是把这个默认值声明成一个类内初始值。

**Note**：当我们提供一个类内初始值时，必须以符号 `=` 或花括号表示。

### 7.3.2 返回 *this 的成员函数

#### 从 const 成员返回 *this

添加 display 成员函数，我们不希望改变对象，因此 *this 返回的应该是 const 对象，但这样一来导致了不好的后果。如果真的令 display 返回 const 引用，则不能把 display 加入到一组动作序列中去。

**Note**：一个 const 成员函数如果以引用的形式返回 *this，那么它返回的类型是常量引用。

#### 基于 const 的重载

通过区分成员函数是否是 const，我们可以对其重载。

当我们在某个对象上调用 display 时，该对象是否是 const 决定了应该调用 display 的哪个版本。

成员函数声明为 const 且返回 *this 则返回类型必须也有 const，即常量引用。

**建议**：对于公共代码使用私有功能函数。

### 7.3.3 类类型

每个类定义了唯一的类型，即使成员完全一样，不同名字的类也是不同的类型。

#### 类的声明

如同函数的声明和定义一样，类的声明和定义也可分开。可先声明类但不定义。

```C++
    class Screen;
```

有时被称为 **前向声明**，在其定义之前是一个 **不完全类型**，只可在有限的情景下使用：可以定义指向这种类型的指针或引用，也可以声明（但不能定义）以不完全类型作为参数或者返回类型的函数。

例外情况：直到类被定义之后数据成员才能被声明成这种类型。换句话说，必须先完成类的定义，然后编译器才知道存储该数据成员需要多少空间。所以类的成员不能是他自己，但是却可以包含指向自身类型的指针或引用。

### 7.3.4 友元再探

类可以把非成员函数声明为自己的友元，也可以把其他类声明为友元，还可以把其他类中的成员函数定义成友元。

友元函数定义在类的内部，这样的函数是隐式内联的。

#### 类之间的友元关系

如果一个类指定了友元类，则友元类的成员函数可以访问此类包括非公有成员在内的所有成员。

**Note**：每个类负责控制自己的友元类和友元函数。

#### 令成员函数作为友元

需指明成员函数所属的类。

要想令某个成员函数作为友元，必须仔细组织程序的结构以满足定义和声明的彼此依赖关系。

+ 首先定义一个类，在其中声明友元成员函数，在该函数定义之前，必须先声明控制它的那个类。
+ 定义控制该友元函数的类，其中包括对上一个类的友元函数的友元声明。
+ 最后再定义该友元成员函数，此时它才可使用第二个类的成员。

#### 函数重载和友元

如果一个类想把一组重载函数都当成自己的友元函数，需要在类中分别进行友元声明。

#### 友元声明和作用域

类和非成员函数的声明不是必须在它们的友元声明之前，当一个名字第一次出现在一个友元声明中时，隐式假定该名字在当前作用域是可见的。

即使我们仅仅是声明友元的类的成员调用该友元函数，它也必须是被声明过的。

理解友元声明的作用是影响访问权限，它本身并非普通意义上的声明。

## 7.4 类的作用域

在类的作用域之外，普通数据和函数成员只能由对象、引用或者指针使用成员访问运算符来访问。对于类类型成员则使用作用域运算符 `::` 访问。

```C++
    Screen::pos ht = 24, wd = 80;   // 使用 Sreen 定义的 pos 类型
    Screen scr(ht, wd, ' ');
    Screen *p = &scr;
    char c = scr.get();
    c = p->get();
```

### 作用域和定义在类外部的成员

一个类就是一个作用域，在类的外部，成员的名字被隐藏起来了。

一旦遇到类名，定义剩余的部分就在类的作用域之内了，这里的剩余部分包括参数列表和函数体。

另一方面，函数的返回类型通常出现在函数名之前，因此当成员函数定义在类的外部时，返回类型中使用的名字都位于类的作用域之外，故返回类型也必须指明它是哪个类的成员。

### 7.4.1 名字查找和类的作用域

**名字查找** 过程：

+ 首先在名字所在的块中寻找其声明语句，只考虑在名字的使用之前出现的声明。
+ 如果没找到，继续查找外层作用域。
+ 如果最终没找到，则报错

对于定义在类内部的成员来说，解析其中的名字的方式与上述的查找规则有所区别。类的定义分两步处理：

+ 首先，编译成员声明。
+ 知道类全部可见后才编译函数体。

#### 用于类成员声明的名字查找

这种两阶段的处理方式只适用于成员函数中使用的名字，声明中使用的名字，包括返回类型和参数列表中使用的名字，都必须在使用前确保可见。

#### 类型名要特殊处理

#### 成员定义中普通块作用域的名字查找

成员函数中使用的名字按照如下方式解析：

+ 首先，在成员函数中查找该名字的声明，此时，函数使用之前出现的声明才被考虑。
+ 如果没找到，再在类内继续找。这是类的所以成员均被考虑。
+ 如类内也没找到，则在成员函数定义之前的作用域继续找

一般不建议使用其他成员的名字作为某个成员函数的参数，因为这样一来，类成员就被隐藏了，但仍可以通过 this 指针和作用域运算符得到。

#### 类作用域之后，在外围的作用域中查找

#### 在文件中名字的出现处对其进行解析

当成员函数定义在类外部时，名字查找的第三步不仅要考虑类定义前的全局作用域中的声明，还要考虑在成员函数定义前的全局作用域中的声明。

## 7.5 构造函数再探

### 7.5.1 构造函数初始值列表

如果没有在构造函数初始值列表显示初始化，即使在构造函数体中进行了赋值操作，但这是赋值，而不是初始化，默认初始化也在函数体之前执行了。

#### 构造函数的初始值有时必不可少

如果成员是 const 或者引用，必须将其初始化。

如果成员属于某种类类型但该类还没有定义默认构造函数时，也必须将这个成员初始化。

**Note**：以上这些情况，必须在构造函数初始值列表对他们进行初始化。

**建议**：使用构造函数初始值。

#### 成员初始化的顺序

成员的初始化顺序与他们在类中定义的顺序一致，不会随着构造函数初始值列表的排列顺序变化而变化。

最好令构造函数初始值列表的顺序和成员定义顺序一致，且尽量避免使用一个成员去初始化另外一个成员。

尽量使用构造函数的参数作为成员的初始值，这样就不用考虑初始化顺序。

#### 默认实参和构造函数

### 7.5.2 委托构造函数

C++11 新标准下，可以定义 **委托构造函数**。一个委托构造函数使用它所属类的其他构造函数执行自己的初始化过程。

+ 委托构造函数也是有一个成员初始值列表和一个函数体。
+ 在委托构造函数内，成员初始值列表只有唯一的入口，就是类名本身。
+ 和其他成员初始值一样，类名后面紧跟圆括号括起来的参数列表，参数列表必须与类中另外一个构造函数匹配。

### 7.5.3 默认构造函数的作用

当对象默认初始化或值初始化时自动执行默认构造函数。

默认初始化在以下情况发生：

+ 当我们在块作用域内不使用任何初始值定义一个非静态变量。
+ 当一个类本身含有类类型的成员且使用合成的默认构造函数。
+ 当类类型的成员没有在构造函数初始值列表中显示地初始化。

值初始化在以下情况发生：

+ 在数组初始化的过程中，提供的初始值小于数组大小。
+ 不使用初始值定义局部静态变量。
+ 显示请求值初始化。

如果定义了其他构造函数，那么最好也提供一个默认构造函数。

#### 使用默认构造函数

```C++
    Sales_data obj;
```

### 7.5.4 隐式类类型转换

如果构造函数只接受一个实参，则它实际上定义了转换为此类型的隐式转换机制，称为 **转换构造函数**。

如何去理解。

#### 只允许一步类类型转换

#### 类类型转换不总是有效

#### 抑制构造函数定义的隐式转换

将构造函数声明为 **explicit** 即可，且只在类内添加即可，若定义在类外，类外不用再添加 explicit。

#### explicit 构造函数只能用于直接初始化

#### 为转换显示地使用构造函数

这是被允许的，构造函数被声明为 explicit 只是为了阻止隐式的类类型转换。

#### 标准库中含有显示构造函数的类

+ 接受单参数的哦 `const char*` 的 string 构造函数 *不是* explicit 的。
+ 接受一个容量参数的 vector 构造函数 *是* explicit 的。

### 7.5.5 聚合类

**聚合类** 使得用户可以直接访问其成员，并且具有特殊的初始化语法形式。聚合条件：

+ 所有成员都是 public 的。
+ 没有定义任何构造函数。
+ 没有内类初始值。
+ 没有基类，也没有 virtual 函数。

存在缺点：

+ 要求成员全为 public。
+ 正确初始化任务交给了用户而不是作者。
+ 添加或删除成员后，所有初始化语句都需要更新。

### 7.5.6 字面值常量类

数据成员都是字面值类型的聚合类是字面值常量类。

满足以下要求，也是字面值常量类：

+ 类数据成员都必须是字面值。
+ 类必须至少含有一个 constexpr 构造函数。
+ 如果数据成员含有类内初始值，必须是常量表达式。或属于某种类型，则初始值必须使用该类型的 constexpr 构造函数构造。
+ 类必须使用析构函数的默认定义。

#### constexpr 构造函数

构造函数不能是 const 的，当字面值常量类的构造函数可以是 constexpr 函数，一个字面值常量类必须至少提供一个 constexpr 构造函数。

constexpr 构造函数必须初始化所有数据成员，初始值使用 constexpr 构造函数或常量表达式。

constexpr 构造函数用于生成 constexpr 对象以及 constexpr 函数的参数或返回类型。

## 7.6 类的静态成员

类需要一些变量和类相关而不是和类的各个对象保持关联。

### 声明静态成员

在成员声明前加关键字 static 使得其与类关联在一起。

静态成员可是 public 的也可以是 private的。

静态数据成员可以是常量、引用、指针、类类型等等。

静态成员函数不与任何对象绑定在一起，不包含 this 指针，不能声明成 const，也不能在 static 函数体内使用 this 指针。

### 使用类的静态成员

使用作用域运算符直接访问。

使用类的对象、引用或指针来访问静态成员。

成员函数不用通过作用域运输符就能直接使用静态成员。

### 定义静态成员

在类外部定义时，不重复 static 关键字，该关键字只出现在类内部的声明语句。

必须在类的外部定义和初始化每一个静态成员，一个静态数据成员只能被定义一次。

### 静态成员的类内初始化

通常，类的静态成员不应该在类内进行初始化，但可为静态成员提供 const 整数类型的类内初始值，不过要求静态成员必须是字面值常量类型的 constexpr。初始值必须是常量表达式。

即使常量静态成员在类内被初始化了，通常也该在类的外部定义一下该成员，但是不需要再提供初始值。

### 静态成员能用于某些场景，而普通成员不能

静态成员独立于对象。

可以是不完全类型，静态数据成员的类型可以就是它所属的类型。

可以使用静态成员作为默认实参，非静态成员不行，因为它的值属于对象的一部分，无法真正提供一个对象，以从其中获得成员的值，引发错误。
