# 第十一章 关联容器

[返回总目录](../../README.md)

+ [11.1 使用关联容器](#11.1-使用关联容器)
+ [11.2 关联容器概述](#11.2-关联容器概述)
+ [11.3 关联容器操作](#11.3-关联容器操作)
+ [11.4 无序容器](#11.4-无序容器)

关联容器类型：

按关键字有序保存的元素：
| 名称 | 说明 |
| :---- | :---- |
| map | 关联数组：保存关键字-值对 |
| set | 关键字即值，只保存关键字 |
| multimap | 关键字可重复出现的 map |
| multiset | 关键字可重复出现的 set |

无序集合：
| 名称 | 说明 |
| :---- | :---- |
| unordered_map | 用哈希函数组织的 map |
| unordered_set | set |
| unordered_multimap ||
| unordered_multiset ||

## 11.1 使用关联容器

关联容器支持类型别名。

### 使用 map

声明 map 需指定两个类型，如 `map<string, int> word_count;`。

可以使用范围 for 语句遍历 map，会得到一个 pair 类型的对象，pair 是模板类型，则 `word_count.first` 返回键值，`word_count.second` 返回值。

### 使用 set

关键字即值，声明如 `set<string> exclude;`，可以进行列表初始化。

## 11.2 关联容器概述

+ 关联容器支持普通容器操作。
+ 不支持顺序容器位置相关的操作。
+ 不支持构造函数或插入操作这些接受一个元素值和一个数量值得操作。
+ 关联容器的迭代器都是双向的。

### 11.2.1 定义关联容器

每个关联容器定义了一个默认构造函数，它创建一个指定类型的空容器。

可以将关联容器初始化为另一个同类型的拷贝，或是使用值范围来初始化关联容器，只要这些值可以转化为容器所需的类型。

新标准下，可以进行值初始化。

#### 初始化 multimap 和 multiset

### 11.2.2 关键字类型的要求

关键字类型必须定义元素比较的方法，默认情况下，标准库使用关键字类型的 `<` 运算符来比较两个关键字。

#### 有序容器的关键字类型

可以提供自己定义的操作来代替关键字上的 `<` 运算符，所提供的操作必须在关键字类型上定义一个 **严格弱序**。

#### 使用关键字类型的比较函数

用尖括号指出要定义哪种类型的容器，自定义的操作类型必须在尖括号中紧跟着元素类型给出。

自定义操作类型使用一个函数指针。

### 11.2.3 pair 类型

标准库类型 **pair**，定义在头文件 utility 中。

pair 保存两个数据成员，是一个用来生成特定类型的模板。创建 pair 时，需提供两个类型名。

pair 上的操作：
| 操作 | 说明 |
| :---- | :---- |
| pair<T1, T2> p; ||
| pair<T1, T2> p(v1, v2); ||
| pair<T1, T2> p = (v1, v2); ||
| make_pair(v1,v2) | 返回由 v1 v2 初始化的 pair，且从 v1 v2 推断出类型 |
| p.first ||
| p.second ||
| p1 *relop* p2 ||

## 11.3 关联容器操作

关联容器额外的类型别名：
| 名称 | 说明 |
| :---- | :---- |
| key_type | 此容器类型的关键字类型 |
| mapped_type | 每个关键字关联的类型：只适用于 map |
| value_type | set 中 与 key_type 相同，map 中，为 pair<const key_type, mapped_type\> |

只有 map 类型才定义了 **mapped_type**。

### 11.3.1 关联迭代器

解引用关联容器的迭代器时，得到类型为容器的  value_type 的值的引用。

```C++
    auto map_it = word_count.begin();
    // *map_it 是指向 pair<const string, size_t> 对象的引用
    cout << map_it -> first;
```

#### set 的迭代器是 const 的

#### 遍历关联容器

**Note**：迭代器按关键字升序遍历元素。

#### 关联容器和算法

通常不对关联容器使用泛型算法。

### 11.3.2 添加元素

insert 成员向容器中添加一个元素或一个元素范围。

#### 向 map 添加元素

insert 时，元素类型必须是 pair。

```C++
    word_count.insert({word, 1});
    word_count.insert(make_pair(word, 1));
    word_count.insert(pair<string, size_t>(word, 1));
    word_count.insert(map<string, size_t>::value_type(word, 1));
```

#### 检测 insert 的返回值

对于不包含重复关键字的容器，添加单一元素的 insert 和 emplace 版本返回一个 pair。pair 的 first 成员是一个迭代器，指向具有给定关键字的元素，second 返回 bool 值，成功插入为 true，不成功为 false。

#### 向 multiset 和 multimap 添加元素

### 11.3.3 删除元素

定义了三个版本的 erase，与顺序容器类似。

+ 传递一个迭代器参数，删除迭代器指向的元素
+ 传递迭代器对，删除迭代器之间的元素（左闭合区间）
+ 传递 key_type 参数，删除所有匹配给定关键字的元素，返回实际删除的元素数量

### 11.3.4 map 的下标操作

map 和 unordered_map 的下标操作：
| 操作 | 说明 |
| :---- | :---- |
| c[k] | 返回关键字为 k 的元素，若 k 不在 c 中，添加关键字为 k 的元素，进行值初始化 |
| c.at(k) | 访问关键字为 k 的元素，带参数检查，若 k 不在 c 中，返回 out_of_range 异常 |

#### 使用下标操作的返回值

正常情况下，解引用一个迭代器的返回类型和下标运算符的返回类型一致，而对 map 操作时，下标操作返回 mapped_type 对象，解引用返回 value_type 对象。

### 11.3.5 访问元素

一个关联容器中查找元素的操作：
| 操作 | 说明 |
| :---- | :---- |
| c.find(k) | 返回一个迭代器，若找到关键字为 k 的元素，迭代器指向该元素，否则，指向 尾后迭代器 |
| c.count(k) | 计数 |
| c.lower_bound(k) | 返回迭代器，指向第一个关键字不小于 k 的元素 |
| c.upper_bound(k) | 返回迭代器，指向第一个关键字大于 k 的元素 |
| c.equal_bound(k) | 返回迭代器 pair，表示关键字等于 k 的元素的范围，若 k 不存在， pair 的两个成员均等于 c.end() |

#### 对 map 使用 find 代替下标操作

#### 在 multiset 或 multimap 中查找元素

### 11.3.6 一个单词转换的 map

## 11.4 无序容器

新标准定义了 4 个 **无序关联容器**，这些容器使用 *哈希函数* 和关键字类型 `==` 运算符。

### 使用无序容器

### 管理桶

无序容器在存储上组织为一组桶，每个桶保存零个或多个元素，无序容器使用一个哈希函数将元素映射到桶。

无序容器的性能依赖于哈希函数的质量和桶的数量和大小。

无序容器管理操作：
| 操作 | 说明 |
| :---- | :---- |
| c.bucket_count() | 正在使用的桶的数量 |
| c.max_bucket_count() | 容器能容纳的最多的桶的数量 |
| c.bucket_size() | 第 n 个桶中有多少元素 |
| c.bucket(k) | 关键字为 k 的元素在哪个桶中 |

### 无序容器对关键字类型的要求

自定义 `==` 运算符，自定义哈希函数。
