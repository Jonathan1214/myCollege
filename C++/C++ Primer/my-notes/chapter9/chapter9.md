# 第九章 顺序容器

[返回总目录](../../README.md)

+ [9.1 顺序容器概述](#9.1-顺序容器概述)
+ [9.2 容器库概览](#9.2-容器库概览)
+ [9.3 顺序容器操作](#9.3-顺序容器概览)
+ [9.4 vector 对象是如何增长的](#9.4-vector-对象是如何增长的)
+ [9.5 额外的 string 操作](#9.5-额外的-string-操作)
+ [9.6 容器适配器](#9.6-容器适配器)

## 9.1 顺序容器概述

所有的顺序容器都提供了快速顺序访问元素的能力，但有信能折中：

+ 向容器添加或从容器中删除元素的代价
+ 非顺序访问容器中元素的代价

顺序容器类型：
| 类型 | 说明 |
| :---- | :---- |
| vector | 可变大小数组。支持快速随机访问。在尾部删除或插入元素很慢 |
| deque | 双端队列。支持快速随机访问。头尾插入删除快 |
| list | 双向列表。只支持双向顺序访问。任何位置插入删除都快 |
| forward_list | 单向列表。只支持单向访问。任何位置插入删除快 |
| array | 固定大小数组。支持快速随机访问。不能添加或删除元素 |
| string | 与 vector 相似的容器，专门用于保存字符，随机访问快。在尾部插入删除快 |

string 和 vector 将元素保存在连续的存储空间中。

list 和 forward_list 的设计目的是在任何位置的插入和删除很快，但查找很慢。

deque 更为复杂。

新标准库容器通常性能更好，应该使用。

### 确定使用哪一种容器

通常 vector 是最好的选择，除非有其他的理由。

基本原则：

+ 首先考虑 vector
+ 如果有很多很小的元素，且空间的额外开销很重要，不要使用 list 或 forward_list
+ 要求随机访问，使用 vector 或 deque
+ 要求在容器中间插入或删除，使用 list 或 forward_list
+ 头尾插入，但不在中间插入，使用 deque
+ 只在读取输入时才需要在容器中间位置插入元素，然后随机访问元素————在输入时使用 list，而后拷贝到 vector

如果不确定，则不要使用随机访问，而是使用迭代器，这是公共操作。

## 9.2 容器库概览

容器类型的操作形成了一种层次：

+ 某些操作是所有容器类型都提供的
+ 另外一些仅仅针对顺序容器、关联容器或无序容器
+ 还有一些操作只适用于小部分容器

一般，每类型的容器都定义在一个同名头文件中，且需要提供其中存储元素的类型。

### 对容器可以保存的元素类型的限制

容器操作：
| 类型别名 | 说明 |
| :---- | :---- |
| iterator | 容器的迭代器 |
| const_iterator | 可读取但不可修改元素的迭代器类型 |
| size_type | 无符号整数，足够保存容器的大小 |
| difference_type | 带符号整数类型，保存迭代器间距离 |
| value_type | 元素类型 |
| reference | 元素的左值类型，与 value_type 含义相同 |
| const_reference | 元素的 const 左值类型|

| 构造函数 | 说明 |
| :---- | :---- |
| C c; | 默认构造函数 |
| C c1(c2); | 操作 c2 的拷贝 c1 |
| C c(b, e); | 构造 c，将迭代器 b 和 e 指定的范围内的元素拷贝到 c |
| C c{a, b, c...}; | 列表初始化 c |

| 赋值与 swap | 说明 |
| :---- | :---- |
| c1 = c2; | 将 c1 中的元素替换为 c2 中的元素 |
| c1 = {a, b, c, ...}; | 替换为列表中的元素 |
| a.swap(b) | 交换 a b 中的元素 |
| swap(a, b) | 同上 |

| 大小 | 说明 |
| :---- | :---- |
| c.size() | c 中元素数目 forward_list 不支持|
| c.max_size() | c 可保存的最大元素数目 |
| c.empty() | c 是否为空 |

| 添加/删除元素 | 说明 |
| :---- | :---- |
| c.insert(args) | 拷贝进 c |
| c.emplace(inits) | 使用 inits 构造 c 中的一个元素 |
| c.erase(args) | 删除 args 指定的元素 |
| c.clear() | 删除所有元素 |

| 获取迭代器 | 说明 |
| :---- | :---- |
| c.begin(), c.end() ||
| c.cbegin(), c.cend() ||
| reverse_iterator ||
| const_reverse_iterator ||
| c.rbegin(), c.rend() | 逆序迭代器 |
| c.crbegin(), c.crend() ||

### 9.2.1 迭代器

与容器一样，迭代器有公共接口：如果一个迭代器提供某个操作，那么所有提供相同操作的迭代器对这个操作的实现方式是相同的。

#### 迭代器范围

一个 **迭代器范围** 由一对迭代器表示，两个迭代器分别指向同一个容器中的元素或是尾后元素的位置。

迭代器范围中的元素。

这个元素范围被称为 **左闭合区间**。

#### 使用左闭合范围蕴含的编程假定

假定 begin 和 end 构成一个合法的迭代器范围，则：

+ 如果 begin 和 end 相等，则范围为空。
+ 如果 begin 和 end 不等，则范围至少包含一个元素，且 begin 指向第一个元素。
+ 可以对 begin 递增若干次，使得 begin==end。

### 9.2.2 容器类型成员

### 9.2.3 begin 和 end 成员

### 9.2.4 容器定义和初始化

#### 与顺序容器大小相关的构造函数

#### array 具有固定大小

```C++
    array<int, 4> = ial;
```

### 9.2.5 赋值和 swap

#### 使用 assign（仅顺序容器）

#### 使用 swap

仍指向原来的位置，只是已经是不同的容器。

### 9.2.6 容器大小运算符

### 9.2.7 关系元素符

#### 容器的关系运算符使用元素的关系运算符完成比较

## 9.3 顺序容器操作

顺序容器与关联容器的不同之处在于两者组织元素的方式不同，这与元素的存储、访问、添加和删除直接相关。

### 9.3.1 向顺序容器添加元素

向顺序容器添加元素的操作：
| 操作 | 说明 |
| :---- | :---- |
| c.push_back(t) | 尾部创建元素 |
| c.emplace_back(args) | 头部创建元素 |
| c.push_front(t) | 头部创建元素 |
| c.emplace_front(args) ||
| c.insert(p, t) | 在迭代器 p 指向的元素之前创建一个值为 t 或由args创建的元素 |
| c.emplace(p, args) | 在迭代器 p 指向的元素之前创建一个值为 t 或由args创建的元素 |
| c.insert(p, n, t) ||
| c.insert(p, b, e) ||
| c.insert(p, i1) ||

vector 和 string 不支持 push_front 和 emplace_front

不同容器使用不同的策略来分配元素空间。

#### 使用 push_back

容器元素是拷贝。

#### 使用 push_front

#### 在容器指定位置添加元素

#### 插入范围内的元素

#### 使用 insert 的返回值

#### 使用 emplace 操作

emplace 函数在容器中直接构造元素，传递给 emplace 函数的参数必须与元素类型的构造函数相匹配。

### 9.3.2 访问元素

在顺序容器中访问元素的操作：
| 操作 | 说明 |
| :---- | :---- |
| c.back() | 返回 c 中尾元素的引用 c为空 则行为未定义 |
| c.front() | 返回头元素的引用 |
| c[n] | 下标为 n 的元素的引用 |
| c.at(n) | 下标为 a 元素的引用 超出范围返回 out_of_range 异常 |

at 和下标运算操作只适用于 string、vector、deque 和 array。

#### 访问成员函数返回的是引用

#### 下标操作和安全的随机访问

### 9.3.3 删除元素

顺序容器删除操作：
| 操作 | 说明 |
| c.pop_back() | 删除尾元素 返回 void |
| c.pop_front() | 删除头元素 返回 void |
| c.erase(p) | 删除迭代器 q 指定的元素，返回指向被删除元素之后元素的迭代器 |
| c.erase(b, e) | 删除迭代器 b e 范围内的元素 |
| c.clear() | 清空所有元素 |

#### pop_back 和 pop_front 成员函数

#### 删除多个元素

### 特殊的 forward_list 操作

理解单链表的操作，倒也不难。

在 forward_list 中插入或删除元素：
| 操作 | 解释 |
| :---- | :---- |
| lst.before_begin() | 返回指向链表首元素之前的元素，不可解引用 |
| lst.cbefore_begin() ||
| lst.insert_after(p,t) | 在迭代器 p 后插入元素 t |
| lst.insert_after(p, n, t) ||
| lst.insert_after(p, i1) ||
| emplace_after(p, args) ||
| lst.erase_after(p) ||
| lst.erase_after(b, e) ||

### 9.3.5 改变容器大小

| 操作 | 说明 |
| :---- | :---- |
| resize(n) | 调整为 n 个元素，多余的丢弃，若需添加，进行值初始化 |
| c.resize(n, t)| 需添加的元素用 t 进行初始化 |

### 9.3.6 容器操作可能使得迭代器失效

## 9.4 vector 对象是如何增长的

一次开辟超过所需的空间，以避免每次插入操作都需要开辟空间。

### 管理容量的成员函数

| 操作 | 说明 |
| :---- | :---- |
| c.shrink_to_fit() | 将capacity 调整为 和 size 同样大小 |
| c.capacity() | 不重新分配内存空间的话，c 可以保存多少元素 |
| c.reserve(n) | 分配至少能容纳 n 个元素的空间 |

### capacity 和 size

## 9.5 额外的 string 操作

需要时回来查看。

### 9.5.1 构造 string 的其他方法

### substr 操作

`s.substr(pos,n)` 返回一个 string，从 pos 开始 n 个字符的拷贝。

### 9.5.2 改变 string 的其他操作

#### append 和 replace 函数

### 9.5.3 string 搜索操作

### 9.5.4 compare 函数

### 9.5.5 数值转换

## 9.6 容器适配器

除顺序容器外，标准库还定义了三个顺序容器适配器：stack、queue 和 priority_queue。**适配器** 是标准库中通用的概念。

适配器是一种机制，能使某种事物的行为看起来像另外一种事物一样。

### 定义一个适配器

默认都有两个构造函数：默认构造函数创建一个空对象，接受一个容器类型的构造函数拷贝该容器类型来初始化适配器。

可以在创建一个适配器时将一个命名的顺序容器作为第二个类型参数，来重载默认容器类型。

### 栈适配器

定义在头文件 stack 中。

```C++

```

### 队列适配器
