# 第六章 函数

+ [6.1 函数基础](#6.1-函数基础)
+ [6.2 参数传递](#6.2-参数传递)
+ [6.3 返回类型和 return 语句](#6.3-返回类型和-return-语句)
+ [6.4 函数重载](#6.4-函数重载)
+ [6.5 特殊用途语言特性](#6.5-特殊用途语言特性)
+ [6.6 函数匹配](#6.6-函数匹配)
+ [6.7 函数指针](#6.7-函数指针)

## 6.1 函数基础

典型的函数定义：*返回类型*、*函数名*、由 0 个或多个 *形参* 组成的列表以及函数体。其中，形参以逗号隔开，形参的列表位于一对圆括号内。

通过调用 **调用运算符** 来执行函数。

### 编写函数

### 调用函数

### 形参和实参

每个形参都是含有声明符的声明。

### 函数的返回类型

### 6.1.1 局部对象

在 C++ 中，名字有作用域，对象有 **生命周期**。

+ 名字的作用域是程序文本的一部分，名字在其中可见
+ 对象的生命周期是程序执行过程中该对象存在的一段时间。

形参和函数体内部定义的变量为 **局部变量**，仅在函数作用域内可见，同时局部变量还会 **隐藏** 在外层作用域中同名的其他所有声明中。

#### 自动对象

只存在于块执行期间的对象称为 **自动对象**。

#### 局部静态对象

将局部变量定义成 static 类型从而获得生命周期贯穿函数调用及之后的时间的对象，称之为 **局部静态对象**，其在程序的执行路径第一次经过对象定义语句时初始化，并且直到程序终止时才被销毁，在此期间即使对象所在的函数结束执行也不会对它有影响。

### 6.1.2 函数声明

类似变量，函数只能被定义一次，但可以多次被声明。

函数的声明无需包含函数体，而是用分号代替。

函数声明也称 **函数原型**。

#### 在头文件中进行函数声明

尽量在头文件中进行函数声明，在源文件中进行函数定义。

### 6.1.3 分离式编译

#### 编译和链接多个源文件

## 6.2 参数传递

**Note**：形参初始化的机理与变量初始化一样。

当形参是引用类型时，我们说它对应的实参被 **引用传递** 或者函数被 **传引用调用**，即引用形参是它对应的实参的别名。

当实参的值被拷贝给形参时，形参和实参是两个相互独立的对象。我们说这样的实参被 **值传递** 或者函数 **被传值调用**。

### 6.2.1 传值参数

#### 指针形参

指针形参的行为和其他非引用类型一样，得到的是指针的拷贝值，只不过通过指针可以访问到指针指向的变量。

在 C++ 中，推荐使用引用类型的形参替代指针。

### 6.2.2 传引用参数

#### 使用引用避免拷贝

如果函数不改变引用形参的值，最好将其声明为常量引用。

#### 使用引用形参返回额外信息

额外信息用引用形参传入，在函数体中修改后不需要返回。

### 6.2.3 const 形参和实参

当形参有顶层 const 时，传给他常量对象或者非常量对象都是可以的，因为在实参实例化时，顶层 const 被忽略了。

#### 指针或引用形参与 const

同通用初始化规则，可以使用一个非常量初始化一个底层 const 对象，反之不行。

不能用字面值初始化一个非常量引用。

#### 尽量使用常量引用

因为可以通过普通引用改变传入实参的值，使用常量可以明确要求不能改变参数的值。此外，使用非常量引用也会限制函数所能接受的实参类型，如不能把 const 对象、字面值或需要类型转换的对象传递给普通的引用形参。

### 6.2.4 数组形参

数组特性：不允许拷贝以及使用数组时通常会将其转换为指针。

这导致一些后果：无法以值传递的方式使用数组参数。故实际为函数传递一个数组时，传递的是指向数组首元素的指针。

```C++
    void print(const int *);
    void print(const int[]);
    void print(const int[10]);
    // 以上声明等价
```

#### 使用标记指定数组的长度

要求数组本身包含结束标记，如 C 风格字符串，以标记 `"\0"` 结尾。

#### 使用标准库规范

传递指向数组首元素的指针和指向数组尾元素后一位置的指针。使用 `begin` 和 `end` 函数，这两个函数定义在 iterator 头文件中。

#### 显示传递一个数组大小的形参

#### 数组形参和 const

视是否需改变数组中的元素而定。

#### 数组引用形参

#### 传递多维数组

### 6.2.5 main: 处理命令行选项

命令行选项通过两个可选形参传递给 main 函数：

```C++
    int main(int argc, int *argv[]){ ... }
```

`argv` 的第一个元素指向程序的名字，即 `argv[0]` 为程序名，`arg[1]` 及以后的参数才是我们提供的。

### 6.2.6 含有可变形参的函数

为了编写处理不同数量实参的函数：

+ 如果所有实参类型相同，可以传递一个名为 **initializer_list** 的标准库类型
+ 如果不同，则编写特殊的函数，即所谓可变参数模板

#### initializer_list 形参

如果所有实参类型相同，可以使用 initializer_list 类型的形参，该类型定义在同名头文件中。

initializer_list 提供的操作
| 语法 | 说明 |
| :---- | :---- |
| initializer_list<T\> lst; | 默认初始化：T 类型元素的空列表 |
| initializer_list<T\> lst{a, b, c...} | lst 元素和初始值一样多；lst 的元素是对应初始值的副本；列表中的元素是 const |
| lst2(lst) | 拷贝一个 initializer_list 对象不会拷贝列表中的元素；拷贝后，原始列表和副本共享元素 |
| lst2 = lst | 同上，改成赋值即可 |
| lst.size() | 列表中元素数量 |
| lst.begin() | 返回首元素的指针 |
| lst.end() | 返回尾元素下一位置的指针 |

同 vector 一样，initializer_list 也是模板类型。

#### 省略符形参

## 6.3 返回类型和 return 语句

return 语句返回值的类型必须和函数类型一致，或者可以隐式地转换成函数的返回类型。

### 6.3.1 无返回值的函数

函数无返回值时，返回值类型需被定义为 `void`。

### 6.3.2 有返回值的函数

#### 值是如何被返回的

返回一个值和初始化一个变量或形参的方式完全一样：返回值用于初始化调用点的一个临时量，该临时量就是函数调用的结果。

#### 不要返回局部对象的引用或指针

函数完成后，其占用的资源会被清理，原来位置上的值都会是无定义的。

#### 返回类类型的函数和调用运算符

调用运算符的优先级与点运算符和箭头运算符相同，且满足做结合律，故当函数返回的是类类型时，可直接访问结果对象的成员。

#### 引用返回左值

函数的返回类型决定函数调用是否是左值。调用一个返回类型为引用的函数得到左值，其余返回类型均得到右值。

#### 列表初始化返回值

C++11 新标准规定：函数可以返回花括号包围的值的列表。此时，执行对函数返回的临时量的列表初始化。

#### 主函数 main 的返回值

main 函数会隐式地在最后加上一条 `return 0;` 语句。

#### 递归

如果函数调用了自身，则称之为 **递归函数**。

### 6.3.3 返回数组指针

函数不能拷贝，所有不能返回数组，不过可以返回指向数组的指针或引用。使用类型别名可以简化这种函数的定义。

```C++
    typedef int arrT[10];
    using arrT = int[10];
    arrT *func(int i);
```

#### 声明一个返回数组指针的函数

格式：
    Type (* function(parameter_list))[dimension]

#### 使用尾置返回类型

#### 使用 decltype

## 6.4 函数重载

同一作用域类函数名字相同但形参列表不同，称之为 **函数重载**。

### 定义重载函数

重载的函数应该在形参个数或类型上有所不同。

### 判断两个形参的类型是否相异

### 重载和 const 形参

一个拥有顶层 const 和另一个没有顶层 const 的形参的函数无法区分开。

### const_cast 和重载

### 调用重载的函数

三种可能的结果：

当两个重载函数函数的参数个数一样，且参数类型可以相互转换时，问题存在了，在后面解释。

+ 编译器找不到一个与实参 最佳匹配 的函数，并生成调用该函数的代码。
+ 找不到任何一个函数与调用的实参匹配，此时编译器发出 **无匹配** 错误信息。
+ 有多于一个函数可以匹配，但是每一个都不是明显的最佳选择，此时为 **二义性调用**。

### 6.4.1 重载与作用域

**Note**：在 C++ 中，名字查找发生在类型检查之前。

## 6.5 特殊用途语言特性

函数相关的语言特性：默认实参、内联函数和 constexpr 函数。

### 6.5.1 默认实参

#### 使用默认实参调用函数

函数调用时按照位置解析参数。

#### 默认实参声明

在给定的作用域中一个形参只能被赋予一次默认实参。多次声明时，每次添加的默认实参声明的右边的所有形参必须有默认值。

通常，应该在函数声明中指定默认实参，并将该声明放在合适的头文件中。

#### 默认实参初始值

局部变量不能作为默认实参，允许隐式类型转换存在。

### 6.5.2 内联函数 constexpr 函数

把规模小的操作定义成函数：

+ 阅读和理解函数的调用比读懂等价表达式容易，可通过函数名体现函数作用。
+ 使用函数确保行为的统一。
+ 方便修改
+ 可被其他应用重复调用

#### 内联函数和可避免函数调用的开销

将函数定义为 **内联函数**，通常就是在它的每个调用点上『内联地』展开。在函数的返回类型前加关键字 `inline` 即可。

内联说明可被编译器忽略。

#### constexpr 函数

**constexpr 函数** 是指能用于常量表达式的函数。

约定：函数的返回类型及所有形参的类型都是字面值类型，而且函数体中必须只有一条 return 语句。

constexpr 函数被隐式地指定为内联函数。

**Note**：constexpr 函数不一定返回常量表达式。

#### 把内联函数和 constexpr 函数放在头文件内

### 6.5.3 调试帮助

#### assert 预处理宏

所谓预处理宏就是一个预处理变量，它的行为类似于内联函数。

assert (expr):

首先对 expr 求值，如果表达式为假（即 0），assert 输出信息并终止程序的执行。如果表达式为真，assert 什么也不做。

assert 宏定义在 cassert 头文件中。可直接使用预处理名字而无须提供 using 声明。

assert 宏常用于检查『不能发生』的条件。

#### NDEBUG 预处理变量

assert 的行为依赖于一个名为 NDEBUG 的预处理变量的状态。如果定义了 NDEBUG，则 assert 什么也不做。默认状态下没有定义 NDEBUG，此时 assert 执行运行时检查。

可以使用 `#define` 语句定义 NDEBUG，从而关闭调试状态。也可使用命令行选项。

还可使用 NDEBUG 编写自己的条件调试代码。

预处理器定义的一些对调试有帮助的名字：

+ \_\_func__ 输出当前调试的函数名字
+ \_\_FILE__ 存放文件名的字符串字面值
+ \_\_LINE__ 存放当前行号的整型字面值
+ \_\_TIME__ 存放文件编译时间的字符串字面值
+ \_\_DATE__ 存放文件编译日期的字符串字面值

## 6.6 函数匹配

重载函数形参数量相等，且类型可相互转换时，比较麻烦。

### 确定候选函数和可行函数

函数匹配：

1. 第一步是选定本次调用对应的重载函数集，集合中的函数称为 **候选函数**。具备两个特征：

+ 一是与被调函数同名。
+ 二是其声明在调用点可见。

2. 第二步考察本次调用的提供的实参，然后从候选函数中选出能被这组实参调用的函数，这些选出来的函数称为 **可行函数**。具备两个特征：

+ 形参数量与本次调用提供的形参数量相同。
+ 每个实参的类型与对应的形参类型相同，或者能进行转换。

**Note**：如果没找到可行函数，编译器将报错。

### 寻找最佳匹配（如果有的话）

3. 第三步是从可行函数中选择与本次调用最匹配的函数。实参与形参类型越接近，它们匹配得越好。

### 含有多个形参的函数匹配

如果有且只有一个函数满足如下条件：

+ 该函数每个实参的匹配都不劣于其他可行函数需要的匹配。
+ 至少有一个实参的匹配优于其他可行函数提供的匹配。

则成功调用，否则引发 **二义性调用错误**。

### 6.6.1 实参类型转换

#### 需要类型提升和算术类型转换的匹配

#### 函数匹配和 const 实参

## 6.7 函数指针

函数指针指向的是函数而非对象。函数的类型由返回值类型和形参类型共同决定，与函数名无关。

声明指向函数的指针，用 `指针` 替换函数声明中的函数名即可。

### 使用函数指针

当把函数名作为一个值使用时，自动被转换成指针。

还可直接使用指向函数的指针调用函数，无需解引用。

### 重载函数的指针

使用重载函数时，上下文必须清晰地界定到底应该选用哪个函数。

声明的函数指针类型，必须和某一重载函数函数精确匹配。

### 函数指针形参

同数组类似，虽然不可以定义函数类型的形参，但形参可以是指向函数的指针。此时形参看起来是函数类型，实际上被当成指针使用。

此时，最好使用类型别名，以免显得函数变得冗长。

### 返回指向函数的指针

当有此需求时，必须把返回类型写出指针形式，编译器不会自动地将函数返回类型当成对应的指针类型处理。最好使用类型别名，减少麻烦。

```C++
    using F = int(int *, int);      // 函数类型
    using PF = int(*)(int *, int);  // 函数指针类型

    PF f1(int);     // 正确
    PF f2(int);     // 错误
    PF *f3(int);    // 正确
```

### 使用 auto 和 decltype 用于函数指针类型

使用 decltype 获取的是函数类型而不是函数指针类型。
