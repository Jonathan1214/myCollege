
与vector十分相似，但是大小确定不变。

1. 定义和初始化时，数组的大小必须是一个常量表达式。

维度的类型是size_t

2. 可以显示初始化：
    int a1[] = {0,1,2};  -->> 0,1,2
    int a1[5] = {0,1,2}; -->> 0,1,2,0,0
    注意初始化的值不能超过指定值，也可以不指定个数，由编译器计算。

3. 字符数组的特殊性：
    char a1[] = {"C", "+", "+"};
    char a2[] = {"C", "+", "+", "\0"};
    char a3[] = "C++";   -->> 'C','+','+','\0';
    注意用字符字面值初始化数组时，会在最后面添加空字符，这与C一样。

4. 不允许拷贝和赋值
    如下操作时不被允许的：
    int a2[] = a1;
    a2 = a1;
    事实上，我觉得在C中数组名称其实就是数组指针，所以不能直接拷贝，也不能赋值，我相信在C++中应该也是类似的。

5. 理解复杂的数组声明
    int *ptrs[10];            //ptrs是含有10个整型指针的数组
    int &refs[10] = /* ?*/;   //错误 不存在引用的数组
    int (*Parray)[10] = &arr; //指向一个含有10个整数的数组
    int (&arrRef)[10] = arr;  //arrRef引用一个含有10个整数的数组
    按照由内而外的顺序理解数组。

在C++中，指针和数组有着非常重要的联系，使用数组时，编译器一般会把它转换成指针，这部分和C是相似的。

在C++中，对边界的处理有点不一样，换句话说，C++处理得更加聪明。

6. 只要指针指向的是数组中的元素（或者数组中尾元素的下一位置），都可以执行下标运算：
    int *p = &a[2];
    int j = p[1];   //--->>> *(p+1) 即a[1]
    int k = p[-2];  //--->>> *(p-2) 即a[0]
    需要注意的是，标准库类型string和vector也能执行下标运算，但它们的下标必须是无符号类型，数组内置的下标运算无此要求。

7. C风格的字符串
    注意字符串一定要以空字符'\0'结束。
    strlen() strcmp() strcat() strcpy()
    使用标准库string比使用C风格字符串更加安全高效。


8. 与旧代码的接口
    可以混用string对象和C风格字符串
    可以使用数组初始化vector对象。
    int int_arr[] = {0,1,2,3,4};
    vector<int> ivec(begin(int_arr),end(int_arr));
    最终的结果，ivec包含5个元素。

我们应该尽量使用标准库类型而非数组……，那不是白学了。
